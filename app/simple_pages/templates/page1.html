{% extends "base.html" %}
{% block content %}

    <div class="row">
<div class="text-warning">
    <p class="col-md-12">
        Pylint:Bad code can work. But if it’s buggy, messy and difficult to maintain, it can eventually break a project,
        a development team or even an entire company. The necessity to write clean, professional and maintainable code is
        obvious and is getting more important nowadays as projects grow, more people become involved in development, and
        more projects go open source. In today’s world projects are huge, with dozens and hundreds of people working on
        the same code base. Early detection of possible problems in code plays a huge role in helping developers write clean, professional,
        high-quality code that will be understood by others. Luckily, there are a number of tools that allow Python
        developers to analyse their code against errors and possible perils. These include pyflakes, pylint, pep8, and
        others. The problem, however, is that many developers use them after the code is already written, just to check
        what can be improved. A much more sound approach is, as with Continuous Integration, to find problems early and
        write clean code from the very beginning. This is where IDEs come in with their code intelligence. Pylint is a
        tool that checks for errors in Python code, tries to enforce a coding standard and looks for code
        smells. It can also look for certain type errors, it can recommend suggestions about how particular blocks can
        be refactored and can offer you details about the code’s complexity. Pylint will display a number of messages as
        it analyzes the code and it can also be used for displaying some statistics about the number of warnings and
        errors found in different files. The messages are classified under various categories such as errors and
        warnings. Last but not least, the code is given an overall mark, based on
        the number and severity of the warnings and
        errors.
    </p>
    <p class="col-md-8">
        Pylint Metric: Scientific software is read, not just by computers, but by humans, a lot. Notably, scientists need to know the
        details of the data they produce, and they aren’t likely to blindly trust a code base. What’s more, science is
        about exploring and inventing, so code is often tweaked and modified for new studies.
        When your code is read by fellow scientists, there’s a chance you’ll get some questions. Probably a lot of them,
        if your code isn’t considered “readable” by your readers. That’s either going to take up a lot of your time to
        answer, or possibly discourage people from using your code. That’s too bad, they could have cited you!
        Linters are a shortcut for this future interaction. You can think of them like an extremely pedantic friend.
        Many questions about your coding style, potential bugs and suspicious conduct will be treated as you write code,
        instead of waiting for someone to have to shout at you for it later.
        But how does one define “readability”? What’s readable for me can be obscure to someone else. How can I ever get
        into the future readers’ head? The simple answer is: through standards. Linters are the result of endless
        arguments between thousands of people. They are the pinnacle of compromises when it come to coding style. In
        python, the most consensual writing style is defined by the PEP-8 standard, which the popular pylint package
        enforces. It comes with a handy metric, the Pylint score: you get a 10/10 for perfectly conforming to the
        standard, less it you stray from it.
    </p>
      <p class="col-md-8">
          Pylint Metric: But how does one define “readability”? What’s readable for me can be obscure to someone else. How can I ever get
          into the future readers’ head? The simple answer is: through standards. Linters are the result of endless
          arguments between thousands of people. They are the pinnacle of compromises when it come to coding style. In
          python, the most consensual writing style is defined by the PEP-8 standard, which the popular pylint package
          enforces. It comes with a handy metric, the Pylint score: you get a 10/10 for perfectly conforming to the
          standard, less it you stray from it.
    </p>
    <p class="col-md-8">
        Pylint Tool: The first one is the verbosity of the tool. Some people can be really afraid by the high number of issues that
        Pylint finds in a project. It can be difficult to prioritize all those issues.
        The second is the false positive issue that every Static Analysis tool has. Some checks are clearly known to
        have too many false positives. But I still think those rules are relevant to the Python community. For us,
        there’s, unfortunately, no other way to check for those errors. We can’t understand the language like the
        interpreter does… Python is too dynamic. The third problem that is also linked to the two previous ones is a dearth of contributors to Pylint. Pylint has
        a long history of not being a very friendly project for contributors. Yes, patches are more than welcome, but we
        usually fail at the initial steps, we don’t have a very good documentation, usually it’s better to understand it
        by reading the code etc etc.. After Pylint moved to Github, under the Python Code Quality Authority group,
        things have changed in better, but still I feel we have a lot more to change. I would like to take this opportunity to thank three people that recently had a lot of impact on Pylint. Łukasz
        Rogalski + Cara Vinson (who’s work on Astroid is helping PyLint a lot) + Ashley Whetter. Also, always thanks to
        Florian Bruhin, who is helping us with replies on the mailing list, comments on issue tracker. He helped with
        the move to Github as well, even though he is not contributing to Pylint with code, I consider him part of the
        Pylint team.


    </p>
    <!--
      <p class="col-md-6">
        Git Repositories:Repositories in GIT contain a collection of files of various different versions of a Project.
        These files are imported from the repository into the local server of the user for further updations and
        modifications in the content of the file. A VCS or the Version Control System is used to create these versions
        and store them in a specific place termed as a repository. The process of copying the content from an existing
        Git Repository with the help of various Git Tools is termed as cloning. Once the cloning process is done, the
        user gets the complete repository on his local machine. Git by default assumes the work to be done on the
        repository is as a user, once the cloning is done.Users can also create a new repository or delete an existing
        repository. To delete a repository, the simpler way is to just delete the folder containing the repository.
    </p>
    -->
</div>


</div>

{% endblock %}